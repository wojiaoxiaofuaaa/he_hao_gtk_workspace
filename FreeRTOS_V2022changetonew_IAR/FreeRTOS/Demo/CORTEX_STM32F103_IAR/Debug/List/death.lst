###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         02/May/2024  10:28:28
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\death.c
#    Command line =  
#        -f C:\Users\4444\AppData\Local\Temp\EWF919.tmp
#        (E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\death.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\tool\digital_tool_keil_common_use\keil\IAR\arm\inc\c\DLib_Config_Full.h
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\.\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\inc\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\..\Source\include\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\common\include\
#        -Ol --use_c++_inline --require_prototypes)
#    Locale       =  C
#    List file    =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List\death.lst
#    Object file  =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj\death.o
#
###############################################################################

E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\death.c
      1          /*
      2           * FreeRTOS V202212.01
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * https://www.FreeRTOS.org
     23           * https://github.com/FreeRTOS
     24           *
     25           */
     26          
     27          /**
     28           * Create a single persistent task which periodically dynamically creates another
     29           * two tasks.  The original task is called the creator task, the two tasks it
     30           * creates are called suicidal tasks.
     31           *
     32           * One of the created suicidal tasks kill one other suicidal task before killing
     33           * itself - leaving just the original task remaining.
     34           *
     35           * The creator task must be spawned after all of the other demo application tasks
     36           * as it keeps a check on the number of tasks under the scheduler control.  The
     37           * number of tasks it expects to see running should never be greater than the
     38           * number of tasks that were in existence when the creator task was spawned, plus
     39           * one set of four suicidal tasks.  If this number is exceeded an error is flagged.
     40           *
     41           * \page DeathC death.c
     42           * \ingroup DemoFiles
     43           * <HR>
     44           */
     45          
     46          
     47          #include <stdlib.h>
     48          
     49          /* Scheduler include files. */
     50          #include "FreeRTOS.h"
     51          #include "task.h"
     52          
     53          /* Demo program include files. */
     54          #include "death.h"
     55          
     56          #define deathSTACK_SIZE    ( configMINIMAL_STACK_SIZE + 60 )
     57          
     58          /* The task originally created which is responsible for periodically dynamically
     59           * creating another four tasks. */
     60          static portTASK_FUNCTION_PROTO( vCreateTasks, pvParameters );
     61          
     62          /* The task function of the dynamically created tasks. */
     63          static portTASK_FUNCTION_PROTO( vSuicidalTask, pvParameters );
     64          
     65          /* A variable which is incremented every time the dynamic tasks are created.  This
     66           * is used to check that the task is still running. */
     67          static volatile uint16_t usCreationCount = 0;
     68          
     69          /* Used to store the number of tasks that were originally running so the creator
     70           * task can tell if any of the suicidal tasks have failed to die.
     71           */
     72          static volatile UBaseType_t uxTasksRunningAtStart = 0;
     73          
     74          /* When a task deletes itself, it stack and TCB are cleaned up by the Idle task.
     75           * Under heavy load the idle task might not get much processing time, so it would
     76           * be legitimate for several tasks to remain undeleted for a short period.  There
     77           * may also be a few other unexpected tasks if, for example, the tasks that test
     78           * static allocation are also being used. */
     79          static const UBaseType_t uxMaxNumberOfExtraTasksRunning = 3;
     80          
     81          /* Used to store a handle to the task that should be killed by a suicidal task,
     82           * before it kills itself. */
     83          TaskHandle_t xCreatedTask;
     84          
     85          /*-----------------------------------------------------------*/
     86          
     87          void vCreateSuicidalTasks( UBaseType_t uxPriority )
     88          {
     89              xTaskCreate( vCreateTasks, "CREATOR", deathSTACK_SIZE, ( void * ) NULL, uxPriority, NULL );
     90          }
     91          /*-----------------------------------------------------------*/
     92          
     93          static portTASK_FUNCTION( vSuicidalTask, pvParameters )
     94          {
     95              volatile long l1, l2;
     96              TaskHandle_t xTaskToKill;
     97              const TickType_t xDelay = pdMS_TO_TICKS( ( TickType_t ) 200 );
     98          
     99              /* Test deletion of a task's secure context, if any. */
    100              portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
    101          
    102              if( pvParameters != NULL )
    103              {
    104                  /* This task is periodically created four times.  Two created tasks are
    105                   * passed a handle to the other task so it can kill it before killing itself.
    106                   * The other task is passed in null. */
    107                  xTaskToKill = *( TaskHandle_t * ) pvParameters;
    108              }
    109              else
    110              {
    111                  xTaskToKill = NULL;
    112              }
    113          
    114              for( ; ; )
    115              {
    116                  /* Do something random just to use some stack and registers. */
    117                  l1 = 2;
    118                  l2 = 89;
    119                  l2 *= l1;
    120                  vTaskDelay( xDelay );
    121          
    122                  if( xTaskToKill != NULL )
    123                  {
    124                      /* Make sure the other task has a go before we delete it. */
    125                      vTaskDelay( ( TickType_t ) 0 );
    126          
    127                      /* Kill the other task that was created by vCreateTasks(). */
    128                      vTaskDelete( xTaskToKill );
    129          
    130                      /* Kill ourselves. */
    131                      vTaskDelete( NULL );
    132                  }
    133              }
    134          } /*lint !e818 !e550 Function prototype must be as per standard for task functions. */
    135          /*-----------------------------------------------------------*/
    136          
    137          static portTASK_FUNCTION( vCreateTasks, pvParameters )
    138          {
    139              const TickType_t xDelay = pdMS_TO_TICKS( ( TickType_t ) 1000 );
    140              UBaseType_t uxPriority;
    141          
    142              /* Remove compiler warning about unused parameter. */
    143              ( void ) pvParameters;
    144          
    145              /* Delay at the start to ensure tasks created by other demos have been
    146               * created before storing the current number of tasks. */
    147              vTaskDelay( xDelay );
    148              uxTasksRunningAtStart = ( UBaseType_t ) uxTaskGetNumberOfTasks();
    149          
    150              uxPriority = uxTaskPriorityGet( NULL );
    151          
    152              for( ; ; )
    153              {
    154                  /* Just loop round, delaying then creating the four suicidal tasks. */
    155                  vTaskDelay( xDelay );
    156          
    157                  xCreatedTask = NULL;
    158          
    159                  xTaskCreate( vSuicidalTask, "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
    160                  xTaskCreate( vSuicidalTask, "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );
    161          
    162                  ++usCreationCount;
    163              }
    164          }
    165          /*-----------------------------------------------------------*/
    166          
    167          /* This is called to check that the creator task is still running and that there
    168           * are not any more than four extra tasks. */
    169          BaseType_t xIsCreateTaskStillRunning( void )
    170          {
    171              static uint16_t usLastCreationCount = 0xfff;
    172              BaseType_t xReturn = pdTRUE;
    173              static UBaseType_t uxTasksRunningNow;
    174          
    175              if( usLastCreationCount == usCreationCount )
    176              {
    177                  xReturn = pdFALSE;
    178              }
    179              else
    180              {
    181                  usLastCreationCount = usCreationCount;
    182              }
    183          
    184              uxTasksRunningNow = ( UBaseType_t ) uxTaskGetNumberOfTasks();
    185          
    186              if( uxTasksRunningNow < uxTasksRunningAtStart )
    187              {
    188                  xReturn = pdFALSE;
    189              }
    190              else if( ( uxTasksRunningNow - uxTasksRunningAtStart ) > uxMaxNumberOfExtraTasksRunning )
    191              {
    192                  xReturn = pdFALSE;
    193              }
    194              else
    195              {
    196                  /* Everything is okay. */
    197              }
    198          
    199              return xReturn;
    200          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   vCreateSuicidalTasks
        16   -> xTaskCreate
      32   vCreateTasks
        32   -> uxTaskGetNumberOfTasks
        32   -> uxTaskPriorityGet
        32   -> vTaskDelay
        32   -> xTaskCreate
      24   vSuicidalTask
        24   -> vTaskDelay
        24   -> vTaskDelete
      16   xIsCreateTaskStillRunning
        16   -> uxTaskGetNumberOfTasks


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       8  ?_0
       8  ?_1
       8  ?_2
       2  usCreationCount
       2  usLastCreationCount
       4  uxMaxNumberOfExtraTasksRunning
       4  uxTasksRunningAtStart
       4  uxTasksRunningNow
      24  vCreateSuicidalTasks
      86  vCreateTasks
      62  vSuicidalTask
       4  xCreatedTask
      66  xIsCreateTaskStillRunning

 
  14 bytes in section .bss
   2 bytes in section .data
  28 bytes in section .rodata
 278 bytes in section .text
 
 278 bytes of CODE  memory
  28 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
