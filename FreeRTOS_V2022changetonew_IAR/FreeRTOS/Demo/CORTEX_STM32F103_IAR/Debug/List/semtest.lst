###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         02/May/2024  10:28:29
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\semtest.c
#    Command line =  
#        -f C:\Users\4444\AppData\Local\Temp\EWFC22.tmp
#        (E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\semtest.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\tool\digital_tool_keil_common_use\keil\IAR\arm\inc\c\DLib_Config_Full.h
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\.\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\inc\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\..\Source\include\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\common\include\
#        -Ol --use_c++_inline --require_prototypes)
#    Locale       =  C
#    List file    =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List\semtest.lst
#    Object file  =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj\semtest.o
#
###############################################################################

E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\semtest.c
      1          /*
      2           * FreeRTOS V202212.01
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * https://www.FreeRTOS.org
     23           * https://github.com/FreeRTOS
     24           *
     25           */
     26          
     27          /*
     28           * Creates two sets of two tasks.  The tasks within a set share a variable, access
     29           * to which is guarded by a semaphore.
     30           *
     31           * Each task starts by attempting to obtain the semaphore.  On obtaining a
     32           * semaphore a task checks to ensure that the guarded variable has an expected
     33           * value.  It then clears the variable to zero before counting it back up to the
     34           * expected value in increments of 1.  After each increment the variable is checked
     35           * to ensure it contains the value to which it was just set. When the starting
     36           * value is again reached the task releases the semaphore giving the other task in
     37           * the set a chance to do exactly the same thing.  The starting value is high
     38           * enough to ensure that a tick is likely to occur during the incrementing loop.
     39           *
     40           * An error is flagged if at any time during the process a shared variable is
     41           * found to have a value other than that expected.  Such an occurrence would
     42           * suggest an error in the mutual exclusion mechanism by which access to the
     43           * variable is restricted.
     44           *
     45           * The first set of two tasks poll their semaphore.  The second set use blocking
     46           * calls.
     47           *
     48           */
     49          
     50          
     51          #include <stdlib.h>
     52          
     53          /* Scheduler include files. */
     54          #include "FreeRTOS.h"
     55          #include "task.h"
     56          #include "semphr.h"
     57          
     58          /* Demo app include files. */
     59          #include "semtest.h"
     60          
     61          /* The value to which the shared variables are counted. */
     62          #define semtstBLOCKING_EXPECTED_VALUE        ( ( uint32_t ) 0xfff )
     63          #define semtstNON_BLOCKING_EXPECTED_VALUE    ( ( uint32_t ) 0xff )
     64          
     65          #define semtstSTACK_SIZE                     configMINIMAL_STACK_SIZE
     66          
     67          #define semtstNUM_TASKS                      ( 4 )
     68          
     69          #define semtstDELAY_FACTOR                   ( ( TickType_t ) 10 )
     70          
     71          /* The task function as described at the top of the file. */
     72          static portTASK_FUNCTION_PROTO( prvSemaphoreTest, pvParameters );
     73          
     74          /* Structure used to pass parameters to each task. */
     75          typedef struct SEMAPHORE_PARAMETERS
     76          {
     77              SemaphoreHandle_t xSemaphore;
     78              volatile uint32_t * pulSharedVariable;
     79              TickType_t xBlockTime;
     80          } xSemaphoreParameters;
     81          
     82          /* Variables used to check that all the tasks are still running without errors. */
     83          static volatile short sCheckVariables[ semtstNUM_TASKS ] = { 0 };
     84          static volatile short sNextCheckVariable = 0;
     85          
     86          /*-----------------------------------------------------------*/
     87          
     88          void vStartSemaphoreTasks( UBaseType_t uxPriority )
     89          {
     90              xSemaphoreParameters * pxFirstSemaphoreParameters, * pxSecondSemaphoreParameters;
     91              const TickType_t xBlockTime = ( TickType_t ) 100;
     92          
     93              /* Create the structure used to pass parameters to the first two tasks. */
     94              pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
     95          
     96              if( pxFirstSemaphoreParameters != NULL )
     97              {
     98                  /* Create the semaphore used by the first two tasks. */
     99                  pxFirstSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();
    100          
    101                  if( pxFirstSemaphoreParameters->xSemaphore != NULL )
    102                  {
    103                      xSemaphoreGive( pxFirstSemaphoreParameters->xSemaphore );
    104          
    105                      /* Create the variable which is to be shared by the first two tasks. */
    106                      pxFirstSemaphoreParameters->pulSharedVariable = ( uint32_t * ) pvPortMalloc( sizeof( uint32_t ) );
    107          
    108                      /* Initialise the share variable to the value the tasks expect. */
    109                      *( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
    110          
    111                      /* The first two tasks do not block on semaphore calls. */
    112                      pxFirstSemaphoreParameters->xBlockTime = ( TickType_t ) 0;
    113          
    114                      /* Spawn the first two tasks.  As they poll they operate at the idle priority. */
    115                      xTaskCreate( prvSemaphoreTest, "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( TaskHandle_t * ) NULL );
    116                      xTaskCreate( prvSemaphoreTest, "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( TaskHandle_t * ) NULL );
    117          
    118                      /* vQueueAddToRegistry() adds the semaphore to the registry, if one
    119                       * is in use.  The registry is provided as a means for kernel aware
    120                       * debuggers to locate semaphores and has no purpose if a kernel aware
    121                       * debugger is not being used.  The call to vQueueAddToRegistry() will
    122                       * be removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
    123                       * defined or is defined to be less than 1. */
    124                      vQueueAddToRegistry( ( QueueHandle_t ) pxFirstSemaphoreParameters->xSemaphore, "Counting_Sem_1" );
    125                  }
    126              }
    127          
    128              /* Do exactly the same to create the second set of tasks, only this time
    129               * provide a block time for the semaphore calls. */
    130              pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
    131          
    132              if( pxSecondSemaphoreParameters != NULL )
    133              {
    134                  pxSecondSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();
    135          
    136                  if( pxSecondSemaphoreParameters->xSemaphore != NULL )
    137                  {
    138                      xSemaphoreGive( pxSecondSemaphoreParameters->xSemaphore );
    139          
    140                      pxSecondSemaphoreParameters->pulSharedVariable = ( uint32_t * ) pvPortMalloc( sizeof( uint32_t ) );
    141                      *( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
    142                      pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_PERIOD_MS;
    143          
    144                      xTaskCreate( prvSemaphoreTest, "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( TaskHandle_t * ) NULL );
    145                      xTaskCreate( prvSemaphoreTest, "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( TaskHandle_t * ) NULL );
    146          
    147                      /* vQueueAddToRegistry() adds the semaphore to the registry, if one
    148                       * is in use.  The registry is provided as a means for kernel aware
    149                       * debuggers to locate semaphores and has no purpose if a kernel aware
    150                       * debugger is not being used.  The call to vQueueAddToRegistry() will
    151                       * be removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
    152                       * defined or is defined to be less than 1. */
    153                      vQueueAddToRegistry( ( QueueHandle_t ) pxSecondSemaphoreParameters->xSemaphore, "Counting_Sem_2" );
    154                  }
    155              }
    156          }
    157          /*-----------------------------------------------------------*/
    158          
    159          static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
    160          {
    161              xSemaphoreParameters * pxParameters;
    162              volatile uint32_t * pulSharedVariable, ulExpectedValue;
    163              uint32_t ulCounter;
    164              short sError = pdFALSE, sCheckVariableToUse;
    165          
    166              /* See which check variable to use.  sNextCheckVariable is not semaphore
    167               * protected! */
    168              portENTER_CRITICAL();
    169              sCheckVariableToUse = sNextCheckVariable;
    170              sNextCheckVariable++;
    171              portEXIT_CRITICAL();
    172          
    173              /* A structure is passed in as the parameter.  This contains the shared
    174               * variable being guarded. */
    175              pxParameters = ( xSemaphoreParameters * ) pvParameters;
    176              pulSharedVariable = pxParameters->pulSharedVariable;
    177          
    178              /* If we are blocking we use a much higher count to ensure loads of context
    179               * switches occur during the count. */
    180              if( pxParameters->xBlockTime > ( TickType_t ) 0 )
    181              {
    182                  ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
    183              }
    184              else
    185              {
    186                  ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
    187              }
    188          
    189              for( ; ; )
    190              {
    191                  /* Try to obtain the semaphore. */
    192                  if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
    193                  {
    194                      /* We have the semaphore and so expect any other tasks using the
    195                       * shared variable to have left it in the state we expect to find
    196                       * it. */
    197                      if( *pulSharedVariable != ulExpectedValue )
    198                      {
    199                          sError = pdTRUE;
    200                      }
    201          
    202                      /* Clear the variable, then count it back up to the expected value
    203                       * before releasing the semaphore.  Would expect a context switch or
    204                       * two during this time. */
    205                      for( ulCounter = ( uint32_t ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
    206                      {
    207                          *pulSharedVariable = ulCounter;
    208          
    209                          if( *pulSharedVariable != ulCounter )
    210                          {
    211                              sError = pdTRUE;
    212                          }
    213                      }
    214          
    215                      /* Release the semaphore, and if no errors have occurred increment the check
    216                       * variable. */
    217                      if( xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
    218                      {
    219                          sError = pdTRUE;
    220                      }
    221          
    222                      if( sError == pdFALSE )
    223                      {
    224                          if( sCheckVariableToUse < semtstNUM_TASKS )
    225                          {
    226                              ( sCheckVariables[ sCheckVariableToUse ] )++;
    227                          }
    228                      }
    229          
    230                      /* If we have a block time then we are running at a priority higher
    231                       * than the idle priority.  This task takes a long time to complete
    232                       * a cycle	(deliberately so to test the guarding) so will be starving
    233                       * out lower priority tasks.  Block for some time to allow give lower
    234                       * priority tasks some processor time. */
    235                      if( pxParameters->xBlockTime != ( TickType_t ) 0 )
    236                      {
    237                          vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
    238                      }
    239                  }
    240                  else
    241                  {
    242                      if( pxParameters->xBlockTime == ( TickType_t ) 0 )
    243                      {
    244                          /* We have not got the semaphore yet, so no point using the
    245                           * processor.  We are not blocking when attempting to obtain the
    246                           * semaphore. */
    247                          taskYIELD();
    248                      }
    249                  }
    250              }
    251          }
    252          /*-----------------------------------------------------------*/
    253          
    254          /* This is called to check that all the created tasks are still running. */
    255          BaseType_t xAreSemaphoreTasksStillRunning( void )
    256          {
    257              static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
    258              BaseType_t xTask, xReturn = pdTRUE;
    259          
    260              for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
    261              {
    262                  if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
    263                  {
    264                      xReturn = pdFALSE;
    265                  }
    266          
    267                  sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
    268              }
    269          
    270              return xReturn;
    271          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   prvSemaphoreTest
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vTaskDelay
        24   -> xQueueGenericSend
        24   -> xQueueSemaphoreTake
      32   vStartSemaphoreTasks
        32   -> pvPortMalloc
        32   -> xQueueGenericCreate
        32   -> xQueueGenericSend
        32   -> xTaskCreate
       8   xAreSemaphoreTasksStillRunning


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
     186  prvSemaphoreTest
       8  sCheckVariables
       8  sLastCheckVariables
       2  sNextCheckVariable
     218  vStartSemaphoreTasks
      44  xAreSemaphoreTasksStillRunning

 
  18 bytes in section .bss
  32 bytes in section .rodata
 480 bytes in section .text
 
 480 bytes of CODE  memory
  32 bytes of CONST memory
  18 bytes of DATA  memory

Errors: none
Warnings: none
