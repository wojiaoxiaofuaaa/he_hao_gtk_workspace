###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.1.169/W32 for ARM         02/May/2024  10:28:28
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\BlockQ.c
#    Command line =  
#        -f C:\Users\4444\AppData\Local\Temp\EWF916.tmp
#        (E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\BlockQ.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa082,pe191 -o
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\tool\digital_tool_keil_common_use\keil\IAR\arm\inc\c\DLib_Config_Full.h
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\.\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\STM32F10xFWLib\inc\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\..\Source\include\
#        -I
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\..\common\include\
#        -Ol --use_c++_inline --require_prototypes)
#    Locale       =  C
#    List file    =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\List\BlockQ.lst
#    Object file  =  
#        E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\CORTEX_STM32F103_IAR\Debug\Obj\BlockQ.o
#
###############################################################################

E:\code\free_rtos_revision\FreeRTOS_V2022changetonew_IAR\FreeRTOS\Demo\Common\Minimal\BlockQ.c
      1          /*
      2           * FreeRTOS V202212.01
      3           * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * https://www.FreeRTOS.org
     23           * https://github.com/FreeRTOS
     24           *
     25           */
     26          
     27          /*
     28           * Creates six tasks that operate on three queues as follows:
     29           *
     30           * The first two tasks send and receive an incrementing number to/from a queue.
     31           * One task acts as a producer and the other as the consumer.  The consumer is a
     32           * higher priority than the producer and is set to block on queue reads.  The queue
     33           * only has space for one item - as soon as the producer posts a message on the
     34           * queue the consumer will unblock, pre-empt the producer, and remove the item.
     35           *
     36           * The second two tasks work the other way around.  Again the queue used only has
     37           * enough space for one item.  This time the consumer has a lower priority than the
     38           * producer.  The producer will try to post on the queue blocking when the queue is
     39           * full.  When the consumer wakes it will remove the item from the queue, causing
     40           * the producer to unblock, pre-empt the consumer, and immediately re-fill the
     41           * queue.
     42           *
     43           * The last two tasks use the same queue producer and consumer functions.  This time the queue has
     44           * enough space for lots of items and the tasks operate at the same priority.  The
     45           * producer will execute, placing items into the queue.  The consumer will start
     46           * executing when either the queue becomes full (causing the producer to block) or
     47           * a context switch occurs (tasks of the same priority will time slice).
     48           *
     49           */
     50          
     51          #include <stdlib.h>
     52          
     53          /* Scheduler include files. */
     54          #include "FreeRTOS.h"
     55          #include "task.h"
     56          #include "queue.h"
     57          
     58          /* Demo program include files. */
     59          #include "BlockQ.h"
     60          
     61          #define blckqSTACK_SIZE       configMINIMAL_STACK_SIZE
     62          #define blckqNUM_TASK_SETS    ( 3 )
     63          
     64          #if ( configSUPPORT_DYNAMIC_ALLOCATION == 0 )
     65              #error This example cannot be used if dynamic allocation is not allowed.
     66          #endif
     67          
     68          /* Structure used to pass parameters to the blocking queue tasks. */
     69          typedef struct BLOCKING_QUEUE_PARAMETERS
     70          {
     71              QueueHandle_t xQueue;             /*< The queue to be used by the task. */
     72              TickType_t xBlockTime;            /*< The block time to use on queue reads/writes. */
     73              volatile short * psCheckVariable; /*< Incremented on each successful cycle to check the task is still running. */
     74          } xBlockingQueueParameters;
     75          
     76          /* Task function that creates an incrementing number and posts it on a queue. */
     77          static portTASK_FUNCTION_PROTO( vBlockingQueueProducer, pvParameters );
     78          
     79          /* Task function that removes the incrementing number from a queue and checks that
     80           * it is the expected number. */
     81          static portTASK_FUNCTION_PROTO( vBlockingQueueConsumer, pvParameters );
     82          
     83          /* Variables which are incremented each time an item is removed from a queue, and
     84           * found to be the expected value.
     85           * These are used to check that the tasks are still running. */
     86          static volatile short sBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
     87          
     88          /* Variable which are incremented each time an item is posted on a queue.   These
     89           * are used to check that the tasks are still running. */
     90          static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
     91          
     92          /*-----------------------------------------------------------*/
     93          
     94          void vStartBlockingQueueTasks( UBaseType_t uxPriority )
     95          {
     96              xBlockingQueueParameters * pxQueueParameters1, * pxQueueParameters2;
     97              xBlockingQueueParameters * pxQueueParameters3, * pxQueueParameters4;
     98              xBlockingQueueParameters * pxQueueParameters5, * pxQueueParameters6;
     99              const UBaseType_t uxQueueSize1 = 1, uxQueueSize5 = 5;
    100              const TickType_t xBlockTime = pdMS_TO_TICKS( ( TickType_t ) 1000 );
    101              const TickType_t xDontBlock = ( TickType_t ) 0;
    102          
    103              /* Create the first two tasks as described at the top of the file. */
    104          
    105              /* First create the structure used to pass parameters to the consumer tasks. */
    106              pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
    107          
    108              /* Create the queue used by the first two tasks to pass the incrementing number.
    109               * Pass a pointer to the queue in the parameter structure. */
    110              pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
    111          
    112              /* The consumer is created first so gets a block time as described above. */
    113              pxQueueParameters1->xBlockTime = xBlockTime;
    114          
    115              /* Pass in the variable that this task is going to increment so we can check it
    116               * is still running. */
    117              pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
    118          
    119              /* Create the structure used to pass parameters to the producer task. */
    120              pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
    121          
    122              /* Pass the queue to this task also, using the parameter structure. */
    123              pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
    124          
    125              /* The producer is not going to block - as soon as it posts the consumer will
    126               * wake and remove the item so the producer should always have room to post. */
    127              pxQueueParameters2->xBlockTime = xDontBlock;
    128          
    129              /* Pass in the variable that this task is going to increment so we can check
    130               * it is still running. */
    131              pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
    132          
    133          
    134              /* Note the producer has a lower priority than the consumer when the tasks are
    135               * spawned. */
    136              xTaskCreate( vBlockingQueueConsumer, "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
    137              xTaskCreate( vBlockingQueueProducer, "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
    138          
    139          
    140          
    141              /* Create the second two tasks as described at the top of the file.   This uses
    142               * the same mechanism but reverses the task priorities. */
    143          
    144              pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
    145              pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
    146              pxQueueParameters3->xBlockTime = xDontBlock;
    147              pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
    148          
    149              pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
    150              pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
    151              pxQueueParameters4->xBlockTime = xBlockTime;
    152              pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
    153          
    154              xTaskCreate( vBlockingQueueConsumer, "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
    155              xTaskCreate( vBlockingQueueProducer, "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
    156          
    157          
    158          
    159              /* Create the last two tasks as described above.  The mechanism is again just
    160               * the same.  This time both parameter structures are given a block time. */
    161              pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
    162              pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( UBaseType_t ) sizeof( uint16_t ) );
    163              pxQueueParameters5->xBlockTime = xBlockTime;
    164              pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
    165          
    166              pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
    167              pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
    168              pxQueueParameters6->xBlockTime = xBlockTime;
    169              pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
    170          
    171              xTaskCreate( vBlockingQueueProducer, "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
    172              xTaskCreate( vBlockingQueueConsumer, "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
    173          }
    174          /*-----------------------------------------------------------*/
    175          
    176          static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
    177          {
    178              uint16_t usValue = 0;
    179              xBlockingQueueParameters * pxQueueParameters;
    180              short sErrorEverOccurred = pdFALSE;
    181          
    182              pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
    183          
    184              for( ; ; )
    185              {
    186                  if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
    187                  {
    188                      sErrorEverOccurred = pdTRUE;
    189                  }
    190                  else
    191                  {
    192                      /* We have successfully posted a message, so increment the variable
    193                       * used to check we are still running. */
    194                      if( sErrorEverOccurred == pdFALSE )
    195                      {
    196                          ( *pxQueueParameters->psCheckVariable )++;
    197                      }
    198          
    199                      /* Increment the variable we are going to post next time round.  The
    200                       * consumer will expect the numbers to	follow in numerical order. */
    201                      ++usValue;
    202          
    203                      #if configUSE_PREEMPTION == 0
    204                          taskYIELD();
    205                      #endif
    206                  }
    207              }
    208          }
    209          /*-----------------------------------------------------------*/
    210          
    211          static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
    212          {
    213              uint16_t usData, usExpectedValue = 0;
    214              xBlockingQueueParameters * pxQueueParameters;
    215              short sErrorEverOccurred = pdFALSE;
    216          
    217              pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
    218          
    219              for( ; ; )
    220              {
    221                  if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
    222                  {
    223                      if( usData != usExpectedValue )
    224                      {
    225                          /* Catch-up. */
    226                          usExpectedValue = usData;
    227          
    228                          sErrorEverOccurred = pdTRUE;
    229                      }
    230                      else
    231                      {
    232                          /* We have successfully received a message, so increment the
    233                           * variable used to check we are still running. */
    234                          if( sErrorEverOccurred == pdFALSE )
    235                          {
    236                              ( *pxQueueParameters->psCheckVariable )++;
    237                          }
    238          
    239                          /* Increment the value we expect to remove from the queue next time
    240                           * round. */
    241                          ++usExpectedValue;
    242                      }
    243          
    244                      #if configUSE_PREEMPTION == 0
    245                      {
    246                          if( pxQueueParameters->xBlockTime == 0 )
    247                          {
    248                              taskYIELD();
    249                          }
    250                      }
    251                      #endif
    252                  }
    253              }
    254          }
    255          /*-----------------------------------------------------------*/
    256          
    257          /* This is called to check that all the created tasks are still running. */
    258          BaseType_t xAreBlockingQueuesStillRunning( void )
    259          {
    260              static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
    261              static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
    262              BaseType_t xReturn = pdPASS, xTasks;
    263          
    264              /* Not too worried about mutual exclusion on these variables as they are 16
    265               * bits and we are only reading them. We also only care to see if they have
    266               * changed or not.
    267               *
    268               * Loop through each check variable to and return pdFALSE if any are found not
    269               * to have changed since the last call. */
    270          
    271              for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
    272              {
    273                  if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ] )
    274                  {
    275                      xReturn = pdFALSE;
    276                  }
    277          
    278                  sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
    279          
    280                  if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ] )
    281                  {
    282                      xReturn = pdFALSE;
    283                  }
    284          
    285                  sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
    286              }
    287          
    288              return xReturn;
    289          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   vBlockingQueueConsumer
        24   -> xQueueReceive
      16   vBlockingQueueProducer
        16   -> xQueueGenericSend
      56   vStartBlockingQueueTasks
        56   -> pvPortMalloc
        56   -> xQueueGenericCreate
        56   -> xTaskCreate
       8   xAreBlockingQueuesStillRunning


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       8  sBlockingConsumerCount
       8  sBlockingProducerCount
       8  sLastBlockingConsumerCount
       8  sLastBlockingProducerCount
      64  vBlockingQueueConsumer
      62  vBlockingQueueProducer
     312  vStartBlockingQueueTasks
      70  xAreBlockingQueuesStillRunning

 
  32 bytes in section .bss
  48 bytes in section .rodata
 548 bytes in section .text
 
 548 bytes of CODE  memory
  48 bytes of CONST memory
  32 bytes of DATA  memory

Errors: none
Warnings: none
